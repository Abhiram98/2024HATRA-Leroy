\section{Evaluation}
\label{sec:eval}


We developed \toolname with Stitch commit number 3d352e6 
and we evaluate it on a 
MacBook Pro machine running a macOS Ventura operating system version 13.3. We utilised Python version 3.9.6.
To evaluate it, we used a corpus of \corpusSize small Python programs 
that adhere to the \ptwo{} grammar, each with an average length of 7 lines of code. We attempted to squeeze the maximum number of abstractions out of Stitch. To do so, we allowed Stitch to run until it could no longer create any new abstractions. We discarded abstractions that called another abstraction, as these are typically small and trivial.

Applying Stitch, with no pruning or validation, on lispified input yields 79 total candidates, of which 39 candidates were one line functions, which we pruned for size. 

The remaining 40 candidates were sent through the remainder of the \toolname{} pipeline.  Of these 40 abstractions, we pruned additional 26 candidates: 24 involved macro-like statements and 2 took in invalid parameters.  This leaves 14 as correct extracted functions.

On the other hand, \toolname is able to find 7 abstractions, after applying our techniques. Some of these are listed in figure \ref{fig:leroy-abstractions}. We used a minimum threshold size of 20 AST nodes to ensure larger sized abstractions. 
% Notably, \toolname was also able to find abstractions that created and returned a function. 
\tocheck{We found that each function was applied to 2.5 call sites on average.  Overall, we achieved a compression ratio(original AST size: rewritten AST size) of \avgcompression, excluding the size of the extracted library. Including the library, the corpus grew by 2\% in terms of AST nodes. This is because \textit{closing}(refer section \ref{closing}) increases the size of the abstraction generated by stitch, both in the abstraction's body and at it's call site. However, this is a minor price to pay for increased modularity in the code-base.}




\begin{figure}
    
    % \vspace{0.5cm} % Adjust vertical space between rows
    
    \begin{subfigure}[t]{0.45\textwidth}
        \begin{lstlisting}[language=Python, firstnumber=1]
def assign_print( _param0, _param1,
    _param2,_param3):
    _param1 = _param3
    _param0 = _param2
    return print(_param1 + _param0)
        \end{lstlisting}
        % \caption{Function 1}
        \label{fig:func3}
    \end{subfigure}\hfill
    %
    \begin{subfigure}[t]{0.45\textwidth}
        \begin{lstlisting}[language=Python, firstnumber=1]
def if_print(_param0, _param1,
    _param2, _param3):
    if _param3(_param2):
        print(_param1)
    else:
        print(_param0)
        \end{lstlisting}
        % \caption{Function 2}
        \label{fig:func4}
    \end{subfigure}
    
    \vspace{0.5cm} % Adjust vertical space between rows
    
    \begin{subfigure}[t]{0.45\textwidth}
        \begin{lstlisting}[language=Python, firstnumber=1]
def multi_assign(_param1, _param2,
    _param3):
     x = 1
     y = 2
     z = _param3
     _param2 = _param1
     return (_param2, x, y, z)
        \end{lstlisting}
        % \caption{Function 5}
        \label{fig:func5}
    \end{subfigure}\hfill
    %
\begin{subfigure}[t]{0.45\textwidth}
        \begin{lstlisting}[language=Python, firstnumber=1]
def assign_add(_param0, _param1,
    _param2, _param3):
    if int(_param3):
        _param1 = _param1 + _param2
    else:
        _param1 = _param1 + _param0
    return _param1
        \end{lstlisting}
        % \caption{Function 2}
        \label{fig:func2}
    \end{subfigure}
    
    % \vspace{0.5cm} % Adjust vertical space between rows
    
%     \begin{subfigure}[t]{0.45\textwidth}
%         \begin{lstlisting}[language=Python, firstnumber=1]
% def assign_print_eq(_param0, _param1):
%     x = _param1
%     y = _param0
%     return print(x == y)
%         \end{lstlisting}
%         \caption{Function 7}
%         \label{fig:func7}
%     \end{subfigure}
    
    \caption{Some of the abstractions found by \toolname}
    \label{fig:leroy-abstractions}
\end{figure}

% \todo{what are the other parameters passed in the testing process?}

% \todo{rename to methodology? include limitations here? }
% This shows the necessity of our techniques. 




% % \begin{figure}
% %     \noindent\begin{minipage}{.45\textwidth}
% %     \begin{lstlisting}
% 1
% % def assign_add(_param0, _param1, 
% %                    _param2, _param3):
% %     if int(_param3):
% %         _param1 = _param1 + _param2
% %     else:
% %         _param1 = _param1 + _param0
% %     return _param1
% %     *@\label{cd:use}@*
% %     \end{lstlisting}
    
% %     \centering
% %     \end{minipage}\hfill
% %         \noindent
% %     \begin{minipage}{.45\textwidth}
% %     \begin{lstlisting}
% 2
% % def assign_print(
% %        _param0, _param1, 
% %        _param2,_param3):
% %     _param1 = _param3
% %     _param0 = _param2
% %     return print(_param1 + _param0)
% %     *@\label{cd:use}@*
% %     \end{lstlisting}
    
% %     \centering
% %     \end{minipage}
% %     \begin{minipage}{.35\textwidth}
% %     \begin{lstlisting}
% 3
% % def swap_print(_param0, 
% % _param1,
% % _param2, _param3):
% %     _param1 = _param3
% %     _param0 = _param2
% %     print(_param1)
% %     print(_param0)
% %     tmp = _param1
% %     _param1 = _param0
% %     _param0 = tmp
% %     print(_param1)
% %     return print(_param0)
% %     *@\label{cd:use}@*
% %     \end{lstlisting}
    
% %     \centering
% %     \end{minipage}

% % \begin{minipage}{.45\textwidth}
% %     \begin{lstlisting}
% 4
% % def assign_print_eq(
% %     _param0, _param1):
% %     x = _param1
% %     y = _param0
% %     return print(x == y)
% %     \end{lstlisting}
    
% %     \centering
% %     \end{minipage}\hfill
% %     \begin{minipage}{.45\textwidth}
% %     \begin{lstlisting}
% 5
% % def multi_assign(
% %     _param1, _param2, _param3):
% %     x = 1
% %     y = 2
% %     z = _param3
% %     _param2 = _param1
% %     return (_param2, x, y, z)
% %     \end{lstlisting}
    
% %     \centering
% %     \end{minipage}\hfill

% %     \begin{minipage}{.45\textwidth}
% %     \begin{lstlisting}
% 6
% % def multi_assign_2(
% %     _param1, _param2,
% %     _param3, x):
% %     y = _param3 + x
% %     z = _param2 + y
% %     w = _param1 + z
% %     return (w, y, z)
% %     \end{lstlisting}
    
% %     \centering
% %     \end{minipage}\hfill

% %     \begin{minipage}{.45\textwidth}
% %     \begin{lstlisting}
% 7
% % def if_print(
% %      _param0, _param1,
% %      _param2, _param3):
% %     if _param3(_param2):
% %         print(_param1)
% %     else:
% %         print(_param0)
% %     \end{lstlisting}
    
% %     \centering
% %     \end{minipage}\hfill




    
% %     \caption{Abstractions found by \toolname}
% %     \label{fig:leroy-abstractions}

% % \end{figure}





% \todo{machine ?}
% \todo{Discuss the impact of our pruning methods on utility }